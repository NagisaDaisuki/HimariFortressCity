---
title: C与指针笔记_4-6
date: 2025-09-20
tags: [C]
pinned: false
head:
  - - meta
    - name: description
      content: What is statements select and loop statements Operators  Pointer 
  - - meta
    - name: keywords
      content: 语句 选择 循环 嵌套 运算符 指针 间接变量和常量 指针表达式 指针变量
---

喜欢我 递归迭代 指针数组 数组指针 `const*` 和 `*const` 吗

---

<h1><center>语句</center></h1>

----

## 4.1 空语句

`;`空语句本身不执行任何任务

## 4.2 表达式语句

只要在表达式后面加上一个分号，就可以把表达式转变为语句

~~~
x = y + 3;
ch = getchar();
~~~

是表达式语句

> 类似于printf函数这类没有返回值的函数在标准输出中输出内容的作用称为副作用(side effect)

## 4.3 代码块

- 一对花括号之内的可选的声明和语句列表

~~~
{
    declarations
    statements
}
~~~

## 4.4 if语句

- C 并不具备布尔类型而是用整型来替代
- else语句从属于最靠近它的不完整的if语句

## 4.5 while语句

..............

## 4.9 goto语句

`goto 语句标签;`

1. 资源清理和错误处理(C中没有异常机制)

~~~
#include <stdio.h>
#include <stdlib.h>

int func()
{
    int *p = malloc(100);
    if(!p) goto fail;
    
    FILE *fp = fopen("file.txt","r");
    if(!fp) goto cleanup;
    
    // 正常执行逻辑
    fclose(fp);
    free(p);
    return 0;
cleanup:
    free(p);
fail:
    return -1;
}
~~~

2. 从多层嵌套中快速跳出

~~~
for (int i = 0; i < 5; ++i) {
    for (int j = 0; j < 5; ++j) {
        if (i + j == 6) goto done;
    }
}
done:
printf("Exited nested loops\n");
~~~

goto 是 C 的原始控制流工具，能**跳到代码中的任意标签**；

不推荐**滥用**，但在特定情况下（如资源清理、退出多层嵌套）是非常有效的；

如果你在写**可读性强、模块化的现代代码**，能不用就尽量不用；

如果你在写**驱动、内核、嵌入式或老式 C 代码**，合理使用是完全 OK 的。

## 4.10 总结

<h1><center>操作符和表达式</center></h1>

## 5.1 运算符

- 算数运算符(右结合)

`+ - * / %`除了`%`其他的操作符都适用于整型和浮点型

- 移位操作符(右结合)

`<< >>`左移和右移操作符
左移右边多出来填充0，右移左边多出来填充0或1(具体看是逻辑运算还是算数运算（符号位1填1，符号位0填0）)
> `a << -5`左移-5位是什么意思其实不重要，结果是由编译器决定的，且其结果无意义，不能在程序中出现这种情况

- 位操作符(右结合)

`& | ^`分别执行与或和异或操作

或操作符与左移操作符结合：

~~~
int value = 0b00001010;
int bit_number = 1;
value = value | (1 << bit_number);
// 即 value = 0b00001010 | ob00000010 = 0b00001010 （值没有发生改变）
bit_number = 2;
value = value | (1 << bit_number);
// 即：value = 0b00001010 | 0b00000100 = 0b00001110 （值变成 14）
~~~

- 赋值符和复合赋值符(左结合)

可以用复合赋值符改写上面的操作

~~~
value |= 1 << bit_number;
value &= 1 << bit_number;
~~~

- 单目运算符(左结合)

`~`操作符对二进制数进行求补操作，操作数原为1则为0，原为 0则为1

`&`操作符为取址符

`*`间接访问操作符

`sizeof()`判断操作数类型长度

<h1><center>指针</center></h1>

## 6.1 内存和地址

我们对两件事情感兴趣：

- 内存中的每个位置由一个独一无二的地址标识：
- 内存中的每个位置都包含一个值：

>名字与内存位置之间的关联并不是硬件提供的，而是由编译器为我们实现的。

**硬件仍然通过地址访问内存位置。**

## 6.2 值和类型

- **不能简单地通过检查一个值的位来判断它的类型。**

~~~
int a = 112;
float b = 3.14;
int *c = &a;
int *d = &b;
~~~

在这上面变量a被解释为整型值，但b存储的为浮点值，在内存中却可能被解释为整型值，变成一个非常大的整型值。由于解释方法不同有可能被解释为整数`1078523331`。
> 大部分情况编译器会帮助我们避免这些错误。当程序访问时编译器就会产生浮点型指令。

## 6.3 指针变量的内容

上面的变量c和d为指针，指针初始化是用`&`操作符完成的，该操作数用于产生操作数的内存地址。

区分变量c、d的地址和c、d存储的内容是非常重要的。c、d存储的内容为a、b的地址，c、d的地址为变量自身在内存中的地址。

## 6.4 间接访问操作符

`*`操作符执行**间接访问(idirection)** 或 **解引用(dereferencing the pointer)**。

## 6.5 未初始化和非法的指针

~~~
int *a;
*a = 12;
~~~

> a指向了哪里，我们声明了这个变量但是未对他进行初始化，所以没有办法预测12这个值将存储于什么地方。
>> *无论是哪种情况声明一个指向整型的指针都不会“创建”用于存储整型值的内存空间。*
>
> 所以程序执行这个赋值操作，有可能：
>
> **1.** a的初始值会是个非法地址，这样赋值语句将会出错，从而终止程序。在UNIX系统上这个错误被称为 *“段违例”(segmentation violation)* 或 *内存错误(memory fault)*。它提示程序试图访问一个并未分配给程序的内存空间。
>
> **2.** 对于那些要求整数必须存储于特定边界的机器而言，如果这种类型的数据在内存中的存储地址处于错误的边界上，那么对这个地址进行访问时将会产生一个错误。这个错误在UNIX系统中被称为 *总线错误(bus error)* 。
>
> **3.** 一种更为严重的情况是，这个指针偶尔可能包含了一个合法的地址。接下来的事情很简单：**位于那个位置的值被修改！**
>
## 6.6 NULL指针

要使一个指针变量为NULL可以给它赋一个零值。
> p96 NULL指针用法

- 对一个NULL指针解引用是非法的，因为NULL指针没有指向任何东西。

## 6.7 指针、间接访问和左值

~~~
int a;
int *d = &a;

*d = 10 - *d;       // 1.正确
d = 10 - *d;        // 2.错误
~~~

第一条语句包含了两个间接操作。右边的间接访问作为右值使用，所以它的值d所指向的位置所存储的值(a的值)。左边的间接访问作为左值使用，所以d所指向的位置a把赋值符右边的表达式的计算结果作为它的新值。

第二条语句是非法的，因为它表示把一个整型变量(10 - *d)存储于一个指针变量中，当实际使用的变量类型和应该使用的变量类型不一致时，编译器会发出警告。

## 6.8 指针、间接变量和变量

`*&a = 25` 和 `a = 25`的效力是相同的，但是它涉及更多的操作，且这种写法会使得代码可读性更差。

## 6.9 指针常量

如果变量a存储于位置100

`*100 = 25;`看上去像是把25赋值给a，但是这是错的！因为字面值100的类型是整型而不是指针类型表达式，如果想把25存储于位置100必须使用强制类型转换。

`*(int *)100 = 25;`这种写法合法，但是需要使用这种技巧的地方几乎碰不到！因为*在编译器执行前无法确定变量会存储在内存的什么位置。*

## 6.10 指针的指针

```
int a = 12;
int *b = &a;
int **c = &b;
```

`*`操作符具有从右向左的结合性，表达式`**c`的类型是int，它是指针的指针。`*c`访问c所指向的位置，我们知道这是变量b。

|表达式|相当的表达式|
|:---:|:---:|
|a|12|
|b|&a|
|*b|a,12|
|c|&b|
|*c|b,&a|
|**c|*b,a,12|

## 6.11 指针表达式

符号优先级：() > ++ > * > -

- 分析几个重要的指针表达式

~~~
char ch = 'a';
char * cp = &ch;
~~~

1. `*cp + 1`
2. `*(cp + 1)`
3. `++cp`
4. `cp++`
5. `*++cp`
6. `*cp++`
7. `++*cp`
8. `(*cp)++`
9. `++*++cp`
10. `++*cp++`

- `*cp + 1`
先执行间接访问操作得到它的值，后取得这个值的**副本**执行与1相加的操作。表达式最终结果为字符'b'。该表达式最终结果的存储位置并未清晰定义，所以不是一个合法左值。
- `*(cp + 1)`
指针加法运算的结果是一个右值，之后对这个右值进行间接访问操作后可以将其作为左值使用，尽管`cp + 1`本身并不是左值。

> **间接访问操作符是少数几个其结果为左值的操作符之一。**

- `++cp`和`cp++`唯一区别是这两个表达式的返回值一个是cp + 1的副本，一个是cp的副本。且这两个表达式都不是合法的左值。
- `*cp++`和`*++cp`与不加间接访问操作的上面两个式子不同。右值为`ch + 1` 或 `ch`那个**内存地址的值**，左值为**那个位置本身**(作为变量使用)。
- `++*cp`与上式不同，由于`*`和`++`操作符都是左结合性，首先执行间接访问操作，然后cp所指向的位置的值加一，表达式结果是这个增值后的值的一个副本。
- `(*cp)++`是原本cp增值前的原先值，和`ch++`操作相同
- `++*++cp`先执行`*++cp`后执行`++*++cp`，结果为`*++cp`自增后的拷贝。
- `++*cp++`和上式的唯一区别是`*++cp`和`*cp++`的区别。

## 6.12 实例

程序6.1：字符串的长度

~~~
#include <stdlib.h>
size_t
strlen(char *string)
{
    int     length = 0;
    while(*string++ != '\0')
        length += 1;
    return length;
}
~~~

程序6.2：在一组字符串中查找指定的字符(版本1)

~~~
#include <stdio.h>
#define     TRUE    1
#define     FALSE   0

int
find_char(char **strings, char value)
{
    char* string;
    // 未初始化的字符串类型
    
    // 对于列表中的每个字符串
    
    while( (string = *strings++) != NULL)
    {
        // 观察字符串中的每个字符
        while( *string != '\0')
        {
            if( *string++ == value)
                return TRUE;
        }
    }
    return FALSE;
}
~~~

程序6.3：在一组字符串中查找(版本2)

~~~
#include <stdio.h>
#include <assert.h>
#define TRUE 1
#define FALSE 0

int 
find_char(char **strings, int value)
{
    assert(strings != NULL);
    while(*strings != NULL)
    {
        while(**strings != '\0')
        {
            if(*(*strings)++ == value)
                return TRUE;
        }
        strings++;
    }
    return FALSE;
}
~~~

## 6.13 指针运算

- 对指针的操作不依赖于指针的类型

### 6.13.1 算数运算

1. 指针 +/- 整数
2. 指针 - 指针
只有两个指针都指向同一个数组中的元素时才允许从一个指针减去另一个指针。

~~~
int arr[5] = {1,2,3,4,5};
int *a = &arr[0];
int *b = &arr[3];
// b - a = 3
// a - b = -3 ----> 指针可以进行反向运算并结果为负数
~~~

### 6.13.2 关系运算

关系运算的前提也是指针都指向一个数组中的元素

用于清除一个数组中的所有元素

~~~
#define N_VALUES    5
float values[N_VALUES];
float *vp;
for(vp = &value[0]; vp < &values[N_VALUES];)
    *vp++ = 0;
~~~

> 这里使用`!=`替换`<`也是可行的

for循环的另一种写法

~~~
for(vp = &values[N_VALUES - 1]; vp >= &values[0];vp--)
    *vp = 0;
~~~

这种写法有一个问题，vp--最后会访问到一个未知的内存位置在满足`vp == &values[0]`后。

## 6.14 总结

- 计算机内存中的每个位置都由一个地址标识。通常邻近的内存位置合成一组，这样就允许存储更大范围的值。指针的值表示的是内存地址的变量。
